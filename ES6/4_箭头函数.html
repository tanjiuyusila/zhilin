<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>箭头函数</title>
</head>
<body>
<ul>
    <li>001</li>
    <li>002</li>
    <li>003</li>
    <li>004</li>
</ul>
<script>
    //1.this指向
    //2.没有arguments
    //3.没有构造函数，不能new
    //匿名函数用得比较多



        // var aLi=document.getElementsByTagName('li');
        // for(var i=0;i<aLi.length;i++){
        //     aLi[i].onclick =function () {
        //         console.log(this.innerHTML)  //该方法属于l i
        //     }
        // }

    //点一下隔一定时间输出li内内容：
    //     var aLi=document.getElementsByTagName('li');
    //     for(var i=0;i<aLi.length;i++){
    //         aLi[i].onclick = function(){    //输出undefined，
    //             setTimeout(function () {   //setTimeout是window下的方法，（小红书第7章：匿名函数中的this指向window）
    //                 console.log(this);   //this不是li,是window对象。
    //                 console.log(this.innerHTML)
    //             },1000)

    //解决方法1：let；
    //解决方法2：
    //         aLi[i].onclick = function(){
    //             var that = this;
    //             setTimeout(function () {
    //                 console.log(that.innerHTML)
    //             },1000)


//this指向问题，常考
    //解决方法3：箭头函数
    //         setTimeout(()=>{  //箭头函数里面的this是定义时指向，普通函数锂的this是运行是指向
    //             //另一种理解：箭头函数没有this。在它上一层找他的指向。
    //             console.log(this.innerHTML)
    //         },1000)
    //     };
    // }
    // 箭头函数不直接定义类（没有构造函数）不能new，可以定义类下的函数

            // var fn = (a,b)=>{    //如果只有一个参数，小括号可以省略。
            //     console.log(a*b)
            // };
            // fn(1,2);


    // this指向例子
    //         var obj = {
    //             name:'zs',
    //             age:12,
    //             // say:function () {
    //             //     console.log(this.name)
    //             // },
    //             say: () => {
    //                 console.log(this.name);   //say方法用箭头函数写，输出undefined，因为箭头函数所在上一层是全局。是window
    //             }
    //         };
    //         obj.say();


//传参问题：
//         function fn(a) {
//             console.log(a);  //法1
//         }
//         function fn() {
//             console.log(arguments[0]);  //不传参，也好使
//         }
//         fn(1);

        // var fn = ()=>{
        //     console.log(arguments[0]);
        // }
        // fn(1);             //报错，没有arguments
        //arguments不好使，如何不传参也实现功能呢：


//箭头函数定义类问题：
//          var User = ()=>{
//              this.name = 'zs';
//          };
//          var u = new User();
//         console.log(u.name);   //b报错，箭头函数没有构造函数，不能使用new关键字去操作一个函数




</script>
</body>
</html>