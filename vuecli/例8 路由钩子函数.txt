例8：路由钩子函数
  写在路由中；
  1. 路由导航守卫；
        a.全局守卫
        router.beforeEach((to,from,next) => {
          console.log(to);//跳转到的路由
          console.log(from);//从那个路由开始跳
          if(from.name == 'mine'){
            next(false)
          }else{
            next(true);//代表允不允许往下走；
          }
            next();
        });
        router.afterEach((to,from) => {
        //全局后置钩子
          console.log(1)
        });
        b. 路由独享钩子:
          beforeEnter:(to,from,next) => {
            if(from.name == 'mine'){
              next(false);
            }else{
              next(true);
            }
          }
  2. 组件内的守卫：在路由组件内直接定义；
        a.beforeRouteEnter(to,from,next){
              //在渲染该组件的对应路由被confirm前调用
              //不能获取组件实例this
              //因为当守卫执行前，组件实例还没有被创建
              console.log(111);
              next();
            },
        b.beforeRouteUpdate (to, from, next) {
              // 在当前路由改变，但是该组件被复用时调用
              // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
              // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
              // 可以访问组件实例 `this`
            },


   完整导航解析流程
    导航被触发。
    在失活的组件里调用离开守卫。
    调用全局的 beforeEach 守卫。
    在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
    在路由配置里调用 beforeEnter。
    解析异步路由组件。
    在被激活的组件里调用 beforeRouteEnter。
    调用全局的 beforeResolve 守卫 (2.5+)。
    导航被确认。
    调用全局的 afterEach 钩子。
    触发 DOM 更新。
    用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。
